name: Publish

on:
  pull_request:
    types: [ closed ] # Trigger when a pull request is closed
    branches: [ main ] # Only trigger for PRs targeting the main branch
  workflow_dispatch: # Allow manual triggering

jobs:
  version-and-tag: # Renamed job
    # Only run on merged PRs or manual dispatch
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to checkout, push tags, commit version bump
    outputs: # Add outputs for other jobs
      new_tag: ${{ steps.version.outputs.new_tag }}
      latest_tag: ${{ steps.version.outputs.latest_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to fetch all history for version calculation

      - name: Set up Deno
        uses: denoland/setup-deno@v1
        # No with: deno-version needed, defaults to latest stable

      - name: Run Tests # Moved earlier
        run: deno test # Add your actual test command here if different

      - name: Determine Version
        id: version
        run: |
          # Fetch all tags
          git fetch --tags
          # Get latest tag like v*.*.* using version sort, or set initial version
          LATEST_TAG=$(git tag --sort=-v:refname | grep '^v[0-9]\+\.[0-9]\+\.[0-9]\+$' | head -n1 || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          # Increment patch version
          IFS='.' read -r -a V_PARTS <<< "${LATEST_TAG#v}"
          MAJOR=${V_PARTS[0]}
          MINOR=${V_PARTS[1]}
          PATCH=${V_PARTS[2]}
          NEW_PATCH=$((PATCH + 1))
          NEW_TAG="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          echo "New tag: $NEW_TAG"
          # Set outputs for subsequent steps
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Update Version, Commit, Tag, and Push
        env:
          NEW_TAG_VAR: ${{ steps.version.outputs.new_tag }} # Pass the tag to an env var
        run: |
          echo "Updating deno.json to version $NEW_TAG_VAR"
          VERSION_NUMBER="${NEW_TAG_VAR#v}"
          echo "Version number for jq: $VERSION_NUMBER"
          jq --arg ver "$VERSION_NUMBER" '.version = $ver' deno.json > tmp.$$.json && mv tmp.$$.json deno.json
          echo "deno.json content after update:"
          cat deno.json

          echo "Configuring git user"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Adding and committing deno.json"
          git add deno.json
          git commit -m "chore: Bump version to $NEW_TAG_VAR"

          echo "Creating and pushing tag ${NEW_TAG_VAR}"
          git tag $NEW_TAG_VAR

          echo "Pushing commit and tag to main"
          # Push the commit on main branch and the new tag
          git push origin main $NEW_TAG_VAR

# Ensure your 'deno task publish' script can use the PUBLISH_VERSION env var
# or update your deno.json(c) version before this step if necessary.
# The above comment is no longer relevant as we use npx jsr publish now.

  publish-package:
    needs: version-and-tag # Depends on the versioning job
    # Only run if the first job succeeded and the trigger conditions were met
    if: always() && needs.version-and-tag.result == 'success' && (github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: read # Need to read repo contents at the tag
      id-token: write # Needed for JSR OIDC authentication
    steps:
      - name: Checkout code at new tag
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.version-and-tag.outputs.new_tag }} # Checkout the specific tag

      - name: Set up Deno
        uses: denoland/setup-deno@v1

      - name: Publish package to JSR
        run: npx jsr publish
        # npx jsr publish reads the version from deno.json automatically

  create-github-release:
    needs: version-and-tag # Depends on the versioning job
    # Only run if the first job succeeded and the trigger conditions were met
    if: always() && needs.version-and-tag.result == 'success' && (github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to create releases
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for release notes generation

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LATEST_TAG: ${{ needs.version-and-tag.outputs.latest_tag }}
          NEW_TAG: ${{ needs.version-and-tag.outputs.new_tag }}
        run: |
          echo "Creating release for tag ${NEW_TAG}"
          # Handle the case where LATEST_TAG is the default v0.0.0 (first release)
          if [ "$LATEST_TAG" == "v0.0.0" ]; then
            echo "Generating release notes from the beginning of history."
            gh release create $NEW_TAG --generate-notes
          else
            echo "Generating release notes since tag ${LATEST_TAG}."
            gh release create $NEW_TAG --generate-notes --notes-start-tag $LATEST_TAG
          fi
